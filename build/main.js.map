{
  "version": 3,
  "sources": ["../src/main.ts"],
  "sourcesContent": ["/*\n * Created with @iobroker/create-adapter v2.0.1\n */\n// TODO: API https://developers.meethue.com/develop/hue-entertainment/hue-hdmi-sync-box-api/#Device%20Discovery\n// The adapter-core module gives you access to the core ioBroker functions\n// you need to create an adapter\nimport * as utils from '@iobroker/adapter-core';\nimport {\n\tbehaviorChannelObj,\n\tbehaviorInputObj,\n\tbehaviorObj,\n\tcapabilitiesObj,\n\tdeviceChannelObj,\n\tdeviceStateObj,\n\texecutionChannelObj,\n\texecutionObj,\n\tgroupsObj,\n\thdmiChannelObj,\n\thdmiInputObj,\n\thdmiObj,\n\thueChannelObj,\n\thueObj,\n\tnetworkObj,\n\tupdateObj,\n\tvideo_game_musicObj,\n} from './lib/object_definition';\n// Load your modules here, e.g.:\n\n// Global variables here\n\nclass HueSyncBox extends utils.Adapter {\n\tprivate rooms: any[];\n\tpublic constructor(options: Partial<utils.AdapterOptions> = {}) {\n\t\tsuper({\n\t\t\t...options,\n\t\t\tname: 'hue-sync-box',\n\t\t});\n\t\tthis.on('ready', this.onReady.bind(this));\n\t\tthis.on('stateChange', this.onStateChange.bind(this));\n\t\t// this.on('objectChange', this.onObjectChange.bind(this));\n\t\t// this.on('message', this.onMessage.bind(this));\n\t\tthis.on('unload', this.onUnload.bind(this));\n\t\tthis.rooms = [];\n\t}\n\n\t/**\n\t * Is called when databases are connected and adapter received configuration.\n\t */\n\tprivate async onReady(): Promise<void> {\n\t\t// Initialize your adapter here\n\t\t// Reset the connection indicator during startup\n\t\tthis.setState('info.connection', false, true);\n\t\tawait this.createStates();\n\t}\n\t//\n\t// private async request(url: string): Promise<void> {\n\t// \ttry {\n\t// \t\t// let data = JSON.stringify({\n\t// \t\t// \thdmi: {\n\t// \t\t// \t\tinput4: {\n\t// \t\t// \t\t\tname: 'test4',\n\t// \t\t// \t\t},\n\t// \t\t// \t},\n\t// \t\t// });\n\t// \t\t// const data2 = JSON.stringify({\n\t// \t\t// \tsyncActive: false,\n\t// \t\t// });\n\t//\n\t// \t\tconst config = {\n\t// \t\t\tmethod: 'get',\n\t// \t\t\turl: url,\n\t// \t\t\theaders: {\n\t// \t\t\t\tAuthorization: `Bearer ${this.config.devices[0].token}`,\n\t// \t\t\t\t'Content-Type': 'application/json',\n\t// \t\t\t},\n\t// \t\t\t// httpsAgent: new https.Agent({ rejectUnauthorized: false }),\n\t// \t\t\t// data: data,\n\t// \t\t};\n\t//\n\t// \t\tconsole.log('request');\n\t// \t\tconst response = await axios(config);\n\t// \t\t// this.log.info('response: ' + JSON.stringify(response.data));\n\t// \t\tconsole.log('response: ', response.data);\n\t// \t} catch (error) {\n\t// \t\tthis.log.error('error: ' + error);\n\t// \t\tconsole.log('error: ', error);\n\t// \t}\n\t// }\n\n\tprivate async createStates(): Promise<void> {\n\t\ttry {\n\t\t\tthis.writeLog(`initializing Object creation`, false, 'debug');\n\t\t\tconst devices = this.config.devices;\n\t\t\t// create the states for the devices\n\t\t\tfor (const device of devices) {\n\t\t\t\tthis.writeLog(`creating device with Name  bax_${device.room}`, false, 'debug');\n\t\t\t\t// create the device\n\t\t\t\tawait this.setObjectNotExistsAsync(`box_${device.room}`, {\n\t\t\t\t\ttype: 'device',\n\t\t\t\t\tcommon: {\n\t\t\t\t\t\tname: device.room,\n\t\t\t\t\t},\n\t\t\t\t\tnative: {},\n\t\t\t\t});\n\n\t\t\t\tthis.writeLog(`creating channel and states for device`, false, 'debug');\n\t\t\t\t// create the channels and states for the device\n\t\t\t\tawait this.setObjectNotExistsAsync(`box_${device.room}.device`, {\n\t\t\t\t\ttype: 'channel',\n\t\t\t\t\tcommon: {\n\t\t\t\t\t\tname: 'device',\n\t\t\t\t\t},\n\t\t\t\t\tnative: {},\n\t\t\t\t});\n\n\t\t\t\tfor (const key in deviceChannelObj) {\n\t\t\t\t\tif (deviceChannelObj.hasOwnProperty(key)) {\n\t\t\t\t\t\tawait this.setObjectNotExistsAsync(`box_${device.room}.device.${key}`, deviceChannelObj[key]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (const key in deviceStateObj) {\n\t\t\t\t\tif (deviceStateObj.hasOwnProperty(key)) {\n\t\t\t\t\t\tawait this.setObjectNotExistsAsync(`box_${device.room}.device.${key}`, deviceStateObj[key]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (const key in networkObj) {\n\t\t\t\t\tif (networkObj.hasOwnProperty(key)) {\n\t\t\t\t\t\tawait this.setObjectNotExistsAsync(`box_${device.room}.device.wifi.${key}`, networkObj[key]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (const key in updateObj) {\n\t\t\t\t\tif (updateObj.hasOwnProperty(key)) {\n\t\t\t\t\t\tawait this.setObjectNotExistsAsync(`box_${device.room}.device.update.${key}`, updateObj[key]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (const key in capabilitiesObj) {\n\t\t\t\t\tif (capabilitiesObj.hasOwnProperty(key)) {\n\t\t\t\t\t\tawait this.setObjectNotExistsAsync(\n\t\t\t\t\t\t\t`box_${device.room}.device.capabilities.${key}`,\n\t\t\t\t\t\t\tcapabilitiesObj[key],\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.writeLog(`creating channel and states for hue`, false, 'debug');\n\t\t\t\tawait this.setObjectNotExistsAsync(`box_${device.room}.hue`, {\n\t\t\t\t\ttype: 'channel',\n\t\t\t\t\tcommon: {\n\t\t\t\t\t\tname: 'hue',\n\t\t\t\t\t},\n\t\t\t\t\tnative: {},\n\t\t\t\t});\n\n\t\t\t\tfor (const key in hueChannelObj) {\n\t\t\t\t\tif (hueChannelObj.hasOwnProperty(key)) {\n\t\t\t\t\t\tawait this.setObjectNotExistsAsync(`box_${device.room}.hue.${key}`, hueChannelObj[key]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (const key in hueObj) {\n\t\t\t\t\tif (hueObj.hasOwnProperty(key)) {\n\t\t\t\t\t\tawait this.setObjectNotExistsAsync(`box_${device.room}.hue.${key}`, hueObj[key]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (const key in groupsObj) {\n\t\t\t\t\tif (groupsObj.hasOwnProperty(key)) {\n\t\t\t\t\t\tawait this.setObjectNotExistsAsync(`box_${device.room}.hue.groups.${key}`, groupsObj[key]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.writeLog(`creating channel and states for execution`, false, 'debug');\n\t\t\t\tawait this.setObjectNotExistsAsync(`box_${device.room}.execution`, {\n\t\t\t\t\ttype: 'channel',\n\t\t\t\t\tcommon: {\n\t\t\t\t\t\tname: 'execution',\n\t\t\t\t\t},\n\t\t\t\t\tnative: {},\n\t\t\t\t});\n\n\t\t\t\tfor (const key in executionChannelObj) {\n\t\t\t\t\tif (executionChannelObj.hasOwnProperty(key)) {\n\t\t\t\t\t\tawait this.setObjectNotExistsAsync(\n\t\t\t\t\t\t\t`box_${device.room}.execution.${key}`,\n\t\t\t\t\t\t\texecutionChannelObj[key],\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (const key in executionObj) {\n\t\t\t\t\tif (executionObj.hasOwnProperty(key)) {\n\t\t\t\t\t\tawait this.setObjectNotExistsAsync(`box_${device.room}.execution.${key}`, executionObj[key]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst array = ['game', 'music', 'video'];\n\t\t\t\tfor (const key in video_game_musicObj) {\n\t\t\t\t\tfor (const arrayKey in array) {\n\t\t\t\t\t\tif (video_game_musicObj.hasOwnProperty(key)) {\n\t\t\t\t\t\t\tawait this.setObjectNotExistsAsync(\n\t\t\t\t\t\t\t\t`box_${device.room}.execution.${array[arrayKey]}.${key}`,\n\t\t\t\t\t\t\t\tvideo_game_musicObj[key],\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.writeLog(`creating channel and states for hdmi`, false, 'debug');\n\t\t\t\tawait this.setObjectNotExistsAsync(`box_${device.room}.hdmi`, {\n\t\t\t\t\ttype: 'channel',\n\t\t\t\t\tcommon: {\n\t\t\t\t\t\tname: 'hdmi',\n\t\t\t\t\t},\n\t\t\t\t\tnative: {},\n\t\t\t\t});\n\n\t\t\t\tfor (const key in hdmiChannelObj) {\n\t\t\t\t\tif (hdmiChannelObj.hasOwnProperty(key)) {\n\t\t\t\t\t\tawait this.setObjectNotExistsAsync(`box_${device.room}.hdmi.${key}`, hdmiChannelObj[key]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (const key in hdmiObj) {\n\t\t\t\t\tif (hdmiObj.hasOwnProperty(key)) {\n\t\t\t\t\t\tawait this.setObjectNotExistsAsync(`box_${device.room}.hdmi.${key}`, hdmiObj[key]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (const key in hdmiInputObj) {\n\t\t\t\t\tif (hdmiInputObj.hasOwnProperty(key)) {\n\t\t\t\t\t\tfor (let i = 1; i < 5; i++) {\n\t\t\t\t\t\t\tawait this.setObjectNotExistsAsync(\n\t\t\t\t\t\t\t\t`box_${device.room}.hdmi.input${i}.${key}`,\n\t\t\t\t\t\t\t\thdmiInputObj[key],\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tawait this.setObjectNotExistsAsync(`box_${device.room}.hdmi.output.${key}`, hdmiInputObj[key]);\n\t\t\t\t}\n\n\t\t\t\tthis.writeLog(`creating channel and states for behavior`, false, 'debug');\n\t\t\t\tawait this.setObjectNotExistsAsync(`box_${device.room}.behavior`, {\n\t\t\t\t\ttype: 'channel',\n\t\t\t\t\tcommon: {\n\t\t\t\t\t\tname: 'behavior',\n\t\t\t\t\t},\n\t\t\t\t\tnative: {},\n\t\t\t\t});\n\n\t\t\t\tfor (const key in behaviorChannelObj) {\n\t\t\t\t\tif (behaviorChannelObj.hasOwnProperty(key)) {\n\t\t\t\t\t\tawait this.setObjectNotExistsAsync(\n\t\t\t\t\t\t\t`box_${device.room}.behavior.${key}`,\n\t\t\t\t\t\t\tbehaviorChannelObj[key],\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (const key in behaviorObj) {\n\t\t\t\t\tif (behaviorObj.hasOwnProperty(key)) {\n\t\t\t\t\t\tawait this.setObjectNotExistsAsync(`box_${device.room}.behavior.${key}`, behaviorObj[key]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (const key in behaviorInputObj) {\n\t\t\t\t\tif (behaviorInputObj.hasOwnProperty(key)) {\n\t\t\t\t\t\tfor (let i = 1; i < 5; i++) {\n\t\t\t\t\t\t\tawait this.setObjectNotExistsAsync(\n\t\t\t\t\t\t\t\t`box_${device.room}.behavior.input${i}.${key}`,\n\t\t\t\t\t\t\t\tbehaviorInputObj[key],\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.writeLog(`all device / channel and states were created`, false, 'debug');\n\t\t} catch (error) {\n\t\t\tthis.writeLog(`[createObjects] ${error.message} Stack: ${error.stack}`, false, 'error');\n\t\t}\n\t}\n\n\t/**\n\t * Is called when adapter shuts down - callback has to be called under any circumstances!\n\t */\n\tprivate onUnload(callback: () => void): void {\n\t\ttry {\n\t\t\t// Here you must clear all timeouts or intervals that may still be active\n\t\t\t// clearTimeout(timeout1);\n\t\t\t// clearTimeout(timeout2);\n\t\t\t// ...\n\t\t\t// clearInterval(interval1);\n\n\t\t\tcallback();\n\t\t} catch (e) {\n\t\t\tcallback();\n\t\t}\n\t}\n\n\t// If you need to react to object changes, uncomment the following block and the corresponding line in the constructor.\n\t// You also need to subscribe to the objects with `this.subscribeObjects`, similar to `this.subscribeStates`.\n\t// /**\n\t//  * Is called if a subscribed object changes\n\t//  */\n\t// private onObjectChange(id: string, obj: ioBroker.Object | null | undefined): void {\n\t// \tif (obj) {\n\t// \t\t// The object was changed\n\t// \t\tthis.log.info(`object ${id} changed: ${JSON.stringify(obj)}`);\n\t// \t} else {\n\t// \t\t// The object was deleted\n\t// \t\tthis.log.info(`object ${id} deleted`);\n\t// \t}\n\t// }\n\n\t/**\n\t * @description a function for log output\n\t */\n\tprivate writeLog(\n\t\tlogtext: string,\n\t\tconsoleLog: boolean,\n\t\tlogtype: 'silly' | 'info' | 'debug' | 'warn' | 'error',\n\t): void {\n\t\ttry {\n\t\t\tif (logtype === 'silly') this.log.silly(logtext);\n\t\t\tif (logtype === 'info') this.log.info(logtext);\n\t\t\tif (logtype === 'debug') this.log.debug(logtext);\n\t\t\tif (logtype === 'warn') this.log.warn(logtext);\n\t\t\tif (logtype === 'error') this.log.error(logtext);\n\t\t\tif (consoleLog) console.log(logtext);\n\t\t} catch (error) {\n\t\t\tthis.log.error(`writeLog error: ${error} , stack: ${error.stack}`);\n\t\t}\n\t}\n\n\t/**\n\t * Is called if a subscribed state changes\n\t */\n\tprivate async onStateChange(id: string, state: ioBroker.State | null | undefined): Promise<void> {\n\t\tif (state) {\n\t\t\tconsole.log('state: ', state.val);\n\t\t\t// The state was changed\n\t\t\tthis.log.info(`state ${id} changed: ${state.val} (ack = ${state.ack})`);\n\t\t\tif (id === this.namespace + '.testVariable') {\n\t\t\t\t// await this.request('http://localhost:3000/api/v1');\n\t\t\t\tawait this.createStates();\n\t\t\t\tconsole.log('testVariable changed');\n\t\t\t}\n\t\t} else {\n\t\t\t// The state was deleted\n\t\t\tthis.log.info(`state ${id} deleted`);\n\t\t}\n\t}\n\n\t// If you need to accept messages in your adapter, uncomment the following block and the corresponding line in the constructor.\n\t// /**\n\t//  * Some message was sent to this instance over message box. Used by email, pushover, text2speech, ...\n\t//  * Using this method requires \"common.messagebox\" property to be set to true in io-package.json\n\t//  */\n\t// private onMessage(obj: ioBroker.Message): void {\n\t// \tif (typeof obj === 'object' && obj.message) {\n\t// \t\tif (obj.command === 'send') {\n\t// \t\t\t// e.g. send email or pushover or whatever\n\t// \t\t\tthis.log.info('send command');\n\n\t// \t\t\t// Send response in callback if required\n\t// \t\t\tif (obj.callback) this.sendTo(obj.from, obj.command, 'Message received', obj.callback);\n\t// \t\t}\n\t// \t}\n\t// }\n}\n\nif (require.main !== module) {\n\t// Export the constructor in compact mode\n\tmodule.exports = (options: Partial<utils.AdapterOptions> | undefined) => new HueSyncBox(options);\n} else {\n\t// otherwise start the instance directly\n\t(() => new HueSyncBox())();\n}\n"],
  "mappings": "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",
  "names": []
}
